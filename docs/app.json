[{"name":"app.R","content":"library(shiny)\r\nlibrary(ggplot2)\r\nlibrary(dplyr)\r\nlibrary(DT)\r\nlibrary(readxl)\r\nlibrary(ciTools)\r\nlibrary(shinyjs)\r\n\r\ndownloadButton <- function(...) {\r\n    tag <- shiny::downloadButton(...)\r\n    tag$attribs$download <- NULL\r\n    tag\r\n}\r\n# creates a shiny app that reads an excel file containing a dataset with at least\r\n# two columns and performs the following regressions: linear, logistic, exponential,\r\n# gaussian and quadric. The user will be able to upload the dataset, to choose\r\n# the columns to be used in the regressions.\r\nregression_functions <- list(\r\n    \"liniara\" = function(x, y) {\r\n        glm(y ~ x, family = gaussian(link = \"identity\"))\r\n    },\r\n    \"exponentiala\" = function(x, y) {\r\n        y[y == 0] <- 1e-10\r\n        glm(y ~ x, family = gaussian(link = \"log\"))\r\n    },\r\n    \"quadratica\" = function(x, y) {\r\n        glm(y ~ poly(x, 2), family = gaussian(link = \"identity\"))\r\n    }\r\n)\r\n\r\ncoef_functions <- list(\r\n    \"liniara\" = function(coef, col_names) {\r\n        y <- col_names[2]\r\n        x <- col_names[1]\r\n        paste0(\"<strong>\", y, \" = \", coef[2], \" * \", x, \" + \", coef[1], \"<br>sau<br>\", \"y = \", coef[2], \" * x + \", coef[1], \"<\/strong>\")\r\n    },\r\n    \"exponentiala\" = function(coef, col_names) {\r\n        y <- col_names[2]\r\n        x <- col_names[1]\r\n        paste0(\"<strong>\", y, \" = exp(\", coef[1], \" + \", coef[2], \" * \", x, \")\", \"<br>sau<br>\", \"y = exp(\", coef[1], \" + \", coef[2], \" * x)<\/strong>\")\r\n    },\r\n    \"quadratica\" = function(coef, col_names) {\r\n        y <- col_names[2]\r\n        x <- col_names[1]\r\n        paste0(\"<strong>\", y, \" = \", coef[3], \" * \", x, \"^2 + \", coef[2], \" * \", x, \" + \", coef[1], \"<br>sau<br>\", \"y = \", coef[3], \" * x^2 + \", coef[2], \" * x + \", coef[1], \"<\/strong>\")\r\n    }\r\n)\r\n\r\nui <- fluidPage(\r\n    useShinyjs(),\r\n    titlePanel(\"Regresie liniară\"),\r\n    wellPanel(\r\n        splitLayout(\r\n            fileInput(\r\n                \"fisier\",\r\n                \"Alege fișierul excel\",\r\n                accept = c(\".xlsx\", \".xls\")\r\n            ),\r\n            checkboxInput(\r\n                \"antet\",\r\n                \"Are antet?\",\r\n                value = TRUE\r\n            )\r\n        ),\r\n        DTOutput(\"tabel\")\r\n    ),\r\n    sidebarLayout(\r\n        sidebarPanel(\r\n            selectInput(\"x\", \"Alege coloana x\", choices = NULL),\r\n            selectInput(\"y\", \"Alege coloana y\", choices = NULL),\r\n            actionButton(\"calcul\", \"Calculează regresiile\")\r\n        ),\r\n        mainPanel(\r\n            downloadButton(\r\n                \"download\",\r\n                \"Descarcă graficele\",\r\n                class = \"btn-danger\"\r\n            ),\r\n            HTML(\"<br><br>\"),\r\n            do.call(\r\n                tagList,\r\n                lapply(names(regression_functions), function(x) {\r\n                    splitLayout(\r\n                        cellWidths = c(\"60%\", \"40%\"),\r\n                        plotOutput(paste0(\"plot_\", x)),\r\n                        htmlOutput(paste0(\"sumar_\", x))\r\n                    )\r\n                })\r\n            )\r\n        )\r\n    )\r\n)\r\n\r\nserver <- function(input, output, session) {\r\n    disable(\"download\")\r\n\r\n    data_frame <- reactive({\r\n        req(input$fisier)\r\n\r\n        isolate({\r\n            df <- read_excel(input$fisier$datapath, col_names = input$antet)\r\n            df <- df[, colSums(is.na(df)) != nrow(df)]\r\n\r\n            current_colnames <- colnames(df)\r\n            for (i in seq_along(current_colnames)) {\r\n                if (startsWith(current_colnames[i], \"...\")) {\r\n                    current_colnames[i] <- paste0(\"Coloana \", i)\r\n                }\r\n            }\r\n            colnames(df) <- current_colnames\r\n            return(as.data.frame(df))\r\n        })\r\n    })\r\n\r\n    output$tabel <- renderDT({\r\n        data_frame()\r\n    })\r\n\r\n    observe({\r\n        df <- data_frame()\r\n\r\n        isolate({\r\n            numeric_columns <- sapply(colnames(df), function(x) {\r\n                na_mask <- !is.na(df[[x]])\r\n                return(all(is.numeric(df[[x]][na_mask])))\r\n            })\r\n            numeric_columns <- colnames(df)[numeric_columns]\r\n            updateSelectInput(session, \"x\", choices = numeric_columns, selected = numeric_columns[1])\r\n            updateSelectInput(session, \"y\", choices = numeric_columns, selected = numeric_columns[2])\r\n        })\r\n    })\r\n\r\n    filtered_df <- reactive({\r\n        choice_x <- input$x\r\n        choice_y <- input$y\r\n\r\n        isolate({\r\n            req(choice_x %in% colnames(data_frame()), choice_y %in% colnames(data_frame()))\r\n            if (choice_x == choice_y) {\r\n                return(NULL)\r\n            }\r\n            new_df <- data_frame()[, c(choice_x, choice_y)]\r\n            new_df <- new_df[complete.cases(new_df), ]\r\n            return(new_df)\r\n        })\r\n    })\r\n\r\n    observe({\r\n        df <- filtered_df()\r\n\r\n        isolate({\r\n            disable(\"calcul\")\r\n            req(!is.null(df), nrow(df) > 0)\r\n            enable(\"calcul\")\r\n        })\r\n    })\r\n\r\n    base_plot <- reactive({\r\n        df <- filtered_df()\r\n\r\n        isolate({\r\n            req(!is.null(df), nrow(df) > 0)\r\n\r\n            return(ggplot(df, aes(x = .data[[colnames(df)[1]]], y = .data[[colnames(df)[[2]]]])) +\r\n                geom_point() +\r\n                theme_classic())\r\n        })\r\n    })\r\n\r\n    # linear\r\n    regr_model_list <- reactive({\r\n        enable(\"download\")\r\n        df <- filtered_df()\r\n\r\n        isolate({\r\n            req(!is.null(df), nrow(df) > 0)\r\n            learned_model <- lapply(names(regression_functions), function(x) {\r\n                regression_functions[[x]](df[, 1], df[, 2])\r\n            })\r\n            names(learned_model) <- names(regression_functions)\r\n            return(learned_model)\r\n        })     \r\n    }) %>% bindEvent(input$calcul)\r\n\r\n    regr_stat_list <- reactive({\r\n        regr_mod <- regr_model_list()\r\n\r\n        isolate({\r\n            orig_cn <- colnames(filtered_df())\r\n            stats_list <- lapply(names(regression_functions), function(x) {\r\n                current_mod <- regr_mod[[x]]\r\n                r2 <- 1 - (current_mod$deviance / current_mod$null.deviance)\r\n                aic <- current_mod$aic\r\n\r\n                table_stats <- data.frame(summary(current_mod)$coefficients)\r\n                colnames(table_stats) <- c(\"Estimate\", \"Std. Error\", \"t value\", \"Pr(>|t|)\")\r\n                tabel_stats <- knitr::kable(table_stats, format = \"html\")\r\n\r\n                formula_str <- coef_functions[[x]](\r\n                    # trim to 2 decimal places\r\n                    round(coef(current_mod), 2),\r\n                    orig_cn\r\n                )\r\n\r\n                # create a string\r\n\r\n                text_mod <- paste0(\r\n                    \"Formulă: \", formula_str, \"<br>\",\r\n                    \"R^2: \", round(r2, 2), \"<br>\",\r\n                    \"AIC: \", round(aic, 2), \"<br>\",\r\n                    \"Coeficienți: \", tabel_stats\r\n                )\r\n\r\n                return(text_mod)\r\n            })\r\n            names(stats_list) <- names(regression_functions)\r\n\r\n            return(stats_list)\r\n        })\r\n    })\r\n\r\n\r\n    regr_plot_list <- reactive({\r\n        regr_mod <- regr_model_list()\r\n        ggobj <- base_plot()\r\n        conf_level <- 0.05\r\n\r\n        isolate({\r\n            plt_list <- lapply(names(regression_functions), function(x) {\r\n                prediction <- add_ci(df = NULL, fit = regr_mod[[x]], alpha = conf_level, names = c(\"lwr\", \"upr\"))\r\n                return(ggobj +\r\n                    geom_ribbon(aes(ymin = prediction$lwr, ymax = prediction$upr), fill = \"gray\", alpha = 0.5) +\r\n                    geom_line(aes(y = prediction$pred), color = \"red\") +\r\n                    ggtitle(paste(\"Regresie\", x))\r\n                )\r\n            })\r\n            names(plt_list) <- names(regression_functions)\r\n\r\n            return(plt_list)\r\n        })\r\n    }) %>% bindEvent(input$calcul)\r\n\r\n    observe({\r\n        regr_plots <- regr_plot_list()\r\n        regr_stats <- regr_stat_list()\r\n\r\n        isolate({\r\n            lapply(names(regression_functions), function(regr_name) {\r\n                output[[paste0(\"plot_\", regr_name)]] <- renderPlot({\r\n                    regr_plots[[regr_name]]\r\n                })\r\n\r\n                output[[paste0(\"sumar_\", regr_name)]] <- renderUI({\r\n                    HTML(regr_stats[[regr_name]])\r\n                })\r\n            })\r\n        })\r\n    })\r\n\r\n    observe({\r\n\r\n        output$download <- downloadHandler(\r\n            filename = function() {\r\n                paste(\"regresii\", \".pdf\", sep = \"\")\r\n            },\r\n            content = function(file) {\r\n                regr_plots <- regr_plot_list()\r\n                isolate({\r\n                    pdf(file, width = 10, height = 10)\r\n                    lapply(names(regression_functions), function(x) {\r\n                        print(regr_plots[[x]])\r\n                        print(x)\r\n                    })\r\n                    dev.off()\r\n                })\r\n            }\r\n        )\r\n    })\r\n}\r\n\r\nshinyApp(ui = ui, server = server)","type":"text"},{"name":"Aplicatie Regresie.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"}]
